<!-- https://github.com/sharedlabs/sortable-list -->
<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../bower_components/polymer/lib/mixins/gesture-event-listeners.html">

<dom-module id="everest-sortable-grid">
  <template>
    <style>
      :host {
        display: block;
        position: relative;

        --items-container-mixin: {
          display: flex;
          justify-content: space-between;
        };

        --item-dragged-mixin: {
          -webkit-box-shadow: 0 2px 10px rgba(0,0,0,.2);
          box-shadow: 0 2px 10px rgba(0,0,0,.2);
          filter: brightness(1.1);
          z-index: 2;
        }
      }

      #items {
        @apply --items-container-mixin;
      }

      ::slotted(*) {
        user-drag: none;
        user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-drag: none;
        -webkit-user-select: none;
        -webkit-tap-highlight-color: rgba(255, 255, 255, 0);
      }

      ::slotted(.item--transform) {
        left: 0;
        margin: 0 !important;
        position: absolute !important;
        top: 0;
        transition: transform 0.2s cubic-bezier(0.333, 0, 0, 1);
        will-change: transform;
        z-index: 1;
      }

      ::slotted(.item--pressed) {
        transition: none !important;
      }

      ::slotted(.item--dragged) {
        @apply --item-dragged-mixin;
        margin: 0 !important;
        position: fixed !important;
        top: 0;
        left: 0;
        transform-origin: left top;
        transition: transform 0.2s cubic-bezier(0.333, 0, 0, 1);
        will-change: transform;
        z-index: 2;
      }
    </style>
    
    <div id="items">
      <slot id="slot"></slot>
    </div>

  </template>

  <script>
  Array.prototype.insert = function ( index, item ) {
    this.splice( index, 0, item );
};

    class EverestSortableGrid extends Polymer.GestureEventListeners(Polymer.Element) {

      static get is() {return 'everest-sortable-grid';}

      static get properties() {
        return {

          /**
           * This is a CSS selector string. If this is set, only items that 
           * match the CSS selector are sortable.
           */
          sortable: String,

          /**
           * The list of sortable items.
           */
          items: {
            type: Array,
            notify: true,
            readOnly: true
          },

          /**
          * Returns true when an item is being drag.
          */
          dragging: {
            type: Boolean,
            notify: true,
            readOnly: true,
            reflectToAttribute: true,
            value: false
          },

          /**
           * Disables the draggable if set to true.
           */
          disabled: {
            type: Boolean,
            reflectToAttribute: true,
            value: false
          }

        };
      }

      /**
       * Init methods
       */
      constructor() {
        super();
        this._observer = null;
        this._target = null;
        this._targetRect = null;
        this._rects = null;
        this._onTrack = this._onTrack.bind(this);
        this._onDragStart = this._onDragStart.bind(this);
        this._onTransitionEnd = this._onTransitionEnd.bind(this);
        this._onContextMenu = this._onContextMenu.bind(this);
        this._onTouchMove = this._onTouchMove.bind(this);
      }

      connectedCallback() {
        super.connectedCallback();
        Polymer.Async.idlePeriod.run(_ => {
          this._observeItems();
          this._updateItems();
          this._toggleListeners({enable: true});
        });
      } 

      disconnectedCallback() {
        super.disconnectedCallback();
        this._unobserveItems();
        this._toggleListeners({enable: false});
      }

      _toggleListeners({enable}) {
        const m = enable ? 'addEventListener' : 'removeEventListener';
        this.$.items[m]('dragstart', this._onDragStart);
        this.$.items[m]('transitionend', this._onTransitionEnd);
        this.$.items[m]('contextmenu', this._onContextMenu);
        this.$.items[m]('touchmove', this._onTouchMove);
        if (enable) {
          Polymer.Gestures.addListener(this, 'track', this._onTrack);
        } else {
          Polymer.Gestures.removeListener(this, 'track', this._onTrack);
        }
      }
      /**
       * End init methods
       */

      /**
       * Global Polymer Gesture event listener (manager)
       *
       * @param      {GestureEvent}  event   The event
       */
      _onTrack(event) {
        switch(event.detail.state) {
          case 'start': this._trackStart(event); break;
          case 'track': this._track(event); break;
          case 'end': this._trackEnd(event); break;
        }
      }

      /**
       * Trigger once on track start
       *
       * @param      {<type>}  event   The event
       */
      _trackStart(event) {
        // console.info("_trackStart");
        if (this.disabled) {
          return;
        }
        this._target = this._itemFromEvent(event);
        if (!this._target) {
          return;
        }
        event.stopPropagation();
        this._rects = this._getItemsRects();
        this._targetRect = this._rects[this.items.indexOf(this._target)];
        this._target.classList.add('item--dragged', 'item--pressed');
        // FIXME : Hack to prevent flashing tile on top beceause of postion fixed
        this._target.style.visibility = 'hidden';
        // Polyfile style
        this._target.style.position = 'fixed !important';
        this._target.style.top = '0';
        this._target.style.left = '0';

        if ('vibrate' in navigator) {
          navigator.vibrate(30);
        }

        // Conserve the current container height as we postion our items out of the box
        const rect = this.getBoundingClientRect();
        this.style.height = rect.height + 'px';

        this.items.forEach((item, idx) => {
          const rect = this._rects[idx];
          item.classList.add('item--transform');
          // Polyfil style
          item.style.position = 'absolute !important';
          item.style.top = '0px';
          item.style.left = '0px';

          item.style.transition = 'none'; // Concel the transition effect as we translate items to their standby position

          item.style.width = rect.width + 'px';
          item.style.height = rect.height + 'px';
          this._translate3d(rect.left, 0, 1, item);
          setTimeout(_ => {
            item.style.transition = null;
          }, 20);
        });
        this._setDragging(true);
      }

      _track(event) {
        // console.log("_track");
        if (!this.dragging) {
          return;
        }

        // Get the de diference from last position
        // https://www.polymer-project.org/2.0/docs/devguide/gesture-events#gesture-event-types
        const left = this._targetRect.left + event.detail.dx;
        const top = this._targetRect.top + event.detail.dy;
        // FIXME : Hack to prevent flashing tile on top beceause of postion fixed
        this._target.style.visibility = 'visible';
        this._translate3d(left, top, 1, this._target);

        // Get the passed item
        const overItem = this._itemFromCoords(event.detail);
        if (overItem && overItem !== this._target) {
          const overItemIndex = this.items.indexOf(overItem);
          const targetIndex = this.items.indexOf(this._target);

          // console.log(this.items);
          this._moveItemArray(this.items, targetIndex, overItemIndex);
          // console.log(this.items);

          for(let i = 0; i < this.items.length; i++) {
            if (this.items[i] !== this._target) {
              const rect = this._rects[i];
              requestAnimationFrame(_ => {
                this._translate3d(rect.left, 0, 1, this.items[i]);
              });
            }
          }
        }
      }

      // The track really ends
      _trackEnd(event) {
        if (!this.dragging) {
          return;
        }
        // console.log("_trackEnd");

        const rect = this._rects[this.items.indexOf(this._target)];
        this._setDragging(false);
        this._translate3d(rect.left, rect.top, 1, this._target);
        this._target.classList.remove('item--pressed');
      }

      _onTransitionEnd() {
        if (this.dragging || !this._target) {
          return;
        }

        this.innerHTML = '';
        this.items.forEach((item, idx) => {
          item.style.transform = '';
          item.style.width = '';
          item.style.heigth = '';
          item.style.cssText = '';

          item.classList.remove('item--transform');
          item.classList.remove('item--dragged');
          if (idx > 0) {
            var newElement=item;
            var targetElement = this.children[idx-1];

            var parent = targetElement.parentNode;
            parent.insertBefore(newElement, targetElement.nextSibling);
          } else {
             this.appendChild(item);
          }
        });

        this.style.height = '';
        this._rects = null;
        this._targetRect = null;
        this._updateItems();
        this.dispatchEvent(new CustomEvent('sort-finish', {
          composed: true,
          detail: {
            target: this._target
          }
        }));
        this._target = null;
      }

      _onDragStart(event) {
        event.preventDefault();
      }

      _onContextMenu(event) {
        if (this.dragging) {
          event.preventDefault();
          this._trackEnd();
        }
      }

      _onTouchMove(event) {
        event.preventDefault();
      }

      _updateItems() {
        if (this.dragging) {
          return;
        }
        const items = this.$.slot.assignedNodes().filter(node => {
          if ((node.nodeType === Node.ELEMENT_NODE) &&
              (!this.sortable || node.matches(this.sortable))) {
            return true;
          }
        });
        this._setItems(items);
      }

      _itemFromCoords({x, y}) {
        if (!this._rects) {return;}
        let match = null;
        this._rects.forEach((rect, i) => {
          if ((x >= rect.left) &&
              (x <= rect.left + rect.width) &&
              (y >= rect.top) &&
              (y <= rect.top + rect.height)) {
            match = this.items[i];
          }
        });
        return match;
      }

      _itemFromEvent(event) {
        const path = event.composedPath();
        for (var i = 0; i < path.length; i++) {
          if (this.items.indexOf(path[i]) > -1) {
            return path[i];
          }
        }
      }

      _getItemsRects() {
        return this.items.map(item => {
          return item.getBoundingClientRect();
        })
      }

      _observeItems() {
        if (!this._observer) {
          this._observer = new MutationObserver(_ => {
            this._updateItems();
          });
          this._observer.observe(this, {childList: true});
        }
      }

      _unobserveItems() {
        if (this._observer) {
          this._observer.disconnect();
          this._observer = null;
        }
      }

      /**
       * Move an array item from one position to another.     
       * Source: http://stackoverflow.com/questions/5306680/move-an-array-element-from-one-array-position-to-another
       */
      _moveItemArray(array, oldIndex, newIndex) {
        if (newIndex >= array.length) {
          var k = newIndex - array.length;
          while ((k--) + 1) {
            array.push(undefined);
          }
        }
        array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);

        return array;
      }

      _translate3d(x, y, z, el) {
        el.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
      }

    }

    customElements.define(EverestSortableGrid.is, EverestSortableGrid);

  </script>
</dom-module>
